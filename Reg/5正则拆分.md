# 拆分

正则这门语言跟其他语言有一点不同，它通常就是一大堆字符，而没有所谓“语句”的概念。

如何能正确地把一大串正则拆分成一块一块的，成为了破解“天书”的关键。

## 结构和操作符

编程语言一般都有操作符。只要有操作符，就会出现一个问题。当一大堆操作在一起时，先操作谁，又后操 作谁呢？为了不产生歧义，就需要语言本身定义好操作顺序，即所谓的优先级。

而在正则表达式中，操作符都体现在结构中，即由特殊字符和普通字符所代表的一个个特殊整体。

JavaScript 正则表达式中有：**字符字面量、字符组、量词、锚、分组、选择分支、反向引用**。

| 结构 | 说明 |
|:- |:- |
| 字面量 | 匹配一个具体字符，包括不用转义的和需要转义的。比如 `a` 匹配字符 `"a"`， 又比如 `\n` 匹配换行符，又比如 `\.` 匹配小数点。|
| 字符组 | 匹配一个字符，可以是多种可能之一，比如 `[0-9]`，表示匹配一个数字。 也有 `\d` 的简写形式。 另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如 `[^0-9]`， 表示一个非数字字符，也有 `\D` 的简写形式。|
| 量词 | 表示一个字符连续出现，比如 `a{1,3}` 表示 `"a"` 字符连续出现 `3` 次。 另外还有常见的简写形式，比如 `a+` 表示 `"a"` 字符连续出现至少一次。|
| 锚 | 匹配一个位置，而不是字符。比如 `^` 匹配字符串的开头，又比如 `\b` 匹配单词边界， 又比如 `(?=\d)` 表示数字前面的位置。|
| 分组 | 用括号表示一个整体，比如 `(ab)+`，表示 `"ab"` 两个字符连续出现多次， 也可以使用非捕获分组 `(?:ab)+`。|
| 分支 | 多个子表达式多选一，比如 `abc|bcd`，表达式匹配 `"abc"` 或者 `"bcd"` 字符子串。 反向引用，比如 `\2`，表示引用第 `2` 个分组。|

其中涉及到的操作符有：

| 操作符描述 | 操作符 | 优先级 |
|:- |:- |:- |
| 转义符  | `\` | 1 |
| 括号和方括号 | `(…)`、`(?:…)`、`(?=…)`、`(?!…)`、`[…]` | 2 |
| 量词限定符 | `{m}`、`{m,n}`、`{m,}`、`?`、`*`、`+` | 3 |
| 位置和序列 |`^`、`$`、`\元字符`、`一般字符` | 4 |
| 管道符（竖杠） | `|` | 5 |

上面操作符的优先级**从上至下，由高到低**

## 注意要点

关于结构和操作符，还是有几点需要强调

### 匹配字符串整体问题

因为是要匹配整个字符串，我们经常会在正则前后中加上锚 `^` 和 `$`。

比如要匹配目标字符串 `"abc"` 或者 `"bcd"` 时，如果一不小心，就会**错误**写成 `/^abc|bcd$/`

应该修改为 `/^(abc|bcd)$/`

### 量词连缀问题

假设，要匹配这样的字符串：

- 每个字符为 `"a"`、`"b"`、`"c"` 任选其一，
- 字符串的长度是 3 的倍数。

此时正则不能想当然地写成 `/^[abc]{3}+$/`，这样会报错，说 `+` 前面没什么可重复的

应该修改为 `/([abc]{3})+/`

### 元字符转义问题

所谓**元字符**，就是正则中有特殊含义的字符

所有结构里，用到的元字符总结如下：

`^`、`$`、`.`、`*`、`+`、`?`、`|`、`\`、`/`、`(`、`)`、`[`、`]`、`{`、`}`、`=`、`!`、`:`、`-` , 当匹配上面的字符本身时，可以一律转义：

```js
var string = "^$.*+?|\\/[]{}=!:-,";
var regex = /\^\$\.\*\+\?\|\\\/\[\]\{\}\=\!\:\-\,/;
console.log( regex.test(string) ); // => true
```

其中 `string` 中的 `\` 字符也要转义的。

另外，在 `string` 中，也可以把每个字符转义，当然，转义后的结果仍是本身：

```js
var string = "^$.*+?|\\/[]{}=!:-,";
var string2 = "\^\$\.\*\+\?\|\\\/\[\]\{\}\=\!\:\-\,";
console.log( string == string2 ); // => true
```

现在的问题是，是不是每个字符都需要转义呢？否，看情况。

#### 字符组中的元字符

跟字符组相关的元字符有 `[`、`]`、`^`、`-`。因此在会引起歧义的地方进行转义。例如开头的 `^` 必须转义，不然 会把整个字符组，看成反义字符组。

```js
var string = "^$.*+?|\\/[]{}=!:-,";
var regex = /[\^$.*+?|\\/\[\]{}=!:\-,]/g;
console.log( string.match(regex) );
// => ["^", "$", ".", "*", "+", "?", "|", "\", "/", "[", "]", "{", "}", "=", "!", ":", "-", ","]
```

#### 匹配 "[abc]" 和 "{3,5}"

我们知道 `[abc]`，是个字符组。如果要匹配字符串 `"[abc]"` 时，该怎么办？
可以写成 `/\[abc\]/`，也可以写成 `/\[abc]/`，测试如下：

```js
var string = "[abc]";
var regex = /\[abc]/g;
console.log( string.match(regex)[0] );
// => "[abc]"
```

只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义

同理，要匹配字符串 `"{3,5}"`，只需要把正则写成 `/\{3,5}/` 即可

另外，我们知道量词有简写形式 `{m,}`，却没有 `{,n}` 的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是 `"{,n}"`，测试如下：

```js
var string = "{,3}";
var regex = /{,3}/g;
console.log( string.match(regex)[0] );
// => "{,3}"
```

#### 其余情况

比如 `=`、`!`、`:`、`-`、, 等符号，只要不在特殊结构中，并不需要转义

但是，括号需要前后都转义的，如 `/\(123\)/`

至于剩下的 `^`、`$`、`.`、`*`、`+`、`?`、`|`、`\`、`/` 等字符，只要不在字符组内，都需要转义的

## 小结

掌握正则表达式中的优先级后，再看任何正则应该都有信心分析下去了。

至于例子，不一而足，没有写太多。

这里稍微总结一下，**竖杠的优先级最低，即最后运算**。

只要知道这一点，就能读懂大部分正则。

另外关于元字符转义问题，当自己不确定与否时，尽管去转义，总之是不会错的。
