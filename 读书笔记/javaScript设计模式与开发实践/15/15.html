<script type="text/javascript">
	var Plane = function(){};

	Plane.prototype.fire = function(){
		console.log( '发射普通子弹' );
	}

	var MissileDecorator = function( plane ){
		this.plane = plane;
	}
	MissileDecorator.prototype.fire = function(){
		this.plane.fire();
		console.log( '发射导弹' );
	}
	var AtomDecorator = function( plane ){
		this.plane = plane;
	}
	AtomDecorator.prototype.fire = function(){
		this.plane.fire();
		console.log( '发射原子弹' );
	}

	var plane = new Plane();
	plane = new MissileDecorator( plane );
	plane = new AtomDecorator( plane );
	plane.fire();

	var plane = {
		fire: function(){
			console.log( '发射普通子弹' );
		}
	}
	var missileDecorator = function(){
		console.log( '发射导弹' );
	}
	var atomDecorator = function(){
		console.log( '发射原子弹' );
	}
	var fire1 = plane.fire;
	plane.fire = function(){
		fire1();
		missileDecorator();
	}
	var fire2 = plane.fire;
	plane.fire = function(){
		fire2();
		atomDecorator();
	}
	plane.fire();
	// 分别输出： 发射普通子弹、发射导弹、发射原子弹

//AOP装饰函数 before  after
	Function.prototype.before = function( beforefn ){
		var __self = this; // 保存原函数的引用
		return function(){ // 返回包含了原函数和新函数的"代理"函数
			beforefn.apply( this, arguments ); // 执行新函数，且保证this 不被劫持，新函数接受的参数
		// 也会被原封不动地传入原函数，新函数在原函数之前执行
			return __self.apply( this, arguments ); // 执行原函数并返回原函数的执行结果，
		// 并且保证this 不被劫持
	}
}
/* 
Function.prototype.before接受一个函数当作参数，这个函数即为新添加的函数，它装载了新添加的功能代码。
接下来把当前的this保存起来，这个this指向原函数，然后返回一个“代理”函数，这个“代理”函数只是结构上像代理而已，并不承担代理的职责（比如控制对象的访问等）。它的工作是把请求分别转发给新添加的函数和原函数，且负责保证它们的执行顺序，让新添加的函数在原函数之前执行（前置装饰），这样就实现了动态装饰的效果。
 */
Function.prototype.after = function( afterfn ){
	var __self = this;
	return function(){
		var ret = __self.apply( this, arguments );
		afterfn.apply( this, arguments );
		return ret;
	}
};

</script>


<html>
<button id="button"></button>
<script>
	Function.prototype.before = function( beforefn ){
		var __self = this;
		return function(){
			beforefn.apply( this, arguments );
			return __self.apply( this, arguments );
		}
	}
	document.getElementById = document.getElementById.before(function(){
		alert (1);
	});
	var button = document.getElementById( 'button' );

	console.log( button );
/* 	上面的AOP实现是在Function.prototype上添加before和after方法，但许多人不喜欢这种污染原型的方式，那么我们可以做一些变通，把原函数和新函数都作为参数传入before或者after方法： */
	var before = function( fn, beforefn ){
		return function(){
			beforefn.apply( this, arguments );
			return fn.apply( this, arguments );
		}
	}
	var a = before(
		function(){alert (3)},
		function(){alert (2)}
		);
	a = before( a, function(){alert (1);} );
	a();
</script>
</html>

<script>
/* 
很多时候我们不想去碰原函数，也许原函数是由其他同事编写的，里面的实现非常杂乱。甚至在一个古老的项目中，这个函数的源代码被隐藏在一个我们不愿碰触的阴暗角落里。现在需要一个办法，在不改变函数源代码的情况下，能给函数增加功能，这正是开放-封闭原则给我们指出的光明道路。
 */
 // 同事写的函数
  var a = function () {
		console.log('同事写的函数');
 }
 var _a = a //  指出来

 a = function () {  // 安全改写
	 _a()
	 console.log('我增加的东西');
 }
 /* 
 这是实际开发中很常见的一种做法，比如我们想给window绑定onload事件，但是又不确定这个事件是不是已经被其他人绑定过，为了避免覆盖掉之前的window.onload函数中的行为，我们一般都会先保存好原先的window.onload，把它放入新的window.onload里执行：
  */
  window.onload = function () {
		alert('1');
	}
var _onload = window.onload() || function() {}

window.onload = function () {
	_onload()
	alert('2');
}
	/* ---- */
	window.onload = function(){
		alert (1);
	}
	window.onload = ( window.onload || function(){} ).after(function(){
		alert (2);
	}).after(function(){
		alert (3);
	}).after(function(){
		alert (4);
	});
</script>

<html>
<button tag="login" id="button">点击打开登录浮层</button>
<script>
	var showLogin = function(){
		console.log( '打开登录浮层' );
		log( this.getAttribute( 'tag' ) );
	}
	var log = function( tag ){
		console.log( '上报标签为: ' + tag );
// (new Image).src = 'http:// xxx.com/report?tag=' + tag; // 真正的上报代码略
}
document.getElementById( 'button' ).onclick = showLogin;
</script>
</html>


<html>
<button tag="login" id="button">点击打开登录浮层</button>
<script>
	Function.prototype.after = function( afterfn ){
		var __self = this;
		return function(){
			var ret = __self.apply( this, arguments );
			afterfn.apply( this, arguments );
			return ret;
		}
	};
	var showLogin = function(){
		console.log( '打开登录浮层' );
	}
	var log = function(){
		console.log( '上报标签为: ' + this.getAttribute( 'tag' ) );
	}

	showLogin = showLogin.after( log ); // 打开登录浮层之后上报数据
	document.getElementById( 'button' ).onclick = showLogin;
</script>
</html>



<html>
<body>
	用户名：<input id="username" type="text"/>

	密码： <input id="password" type="password"/>
	<input id="submitBtn" type="button" value="提交"></button>
</body>
<script>
	var username = document.getElementById( 'username' ),
	password = document.getElementById( 'password' ),
	submitBtn = document.getElementById( 'submitBtn' );
	var formSubmit = function(){
		if ( username.value === '' ){
			return alert ( '用户名不能为空' );
		}
		if ( password.value === '' ){
			return alert ( '密码不能为空' );
		}
		var param = {
			username: username.value,
			password: password.value
		}
		ajax( 'http:// xxx.com/login', param ); // ajax 具体实现略
	}

	submitBtn.onclick = function(){
		formSubmit();
	}


	var validata = function(){
		if ( username.value === '' ){
			alert ( '用户名不能为空' );
			return false;
		}
		if ( password.value === '' ){
			alert ( '密码不能为空' );
			return false;
		}
	}

	var formSubmit = function(){
		if ( validata() === false ){ // 校验未通过
			return;
		}
		var param = {
			username: username.value,
			password: password.value
		}
		ajax( 'http:// xxx.com/login', param );
	}


	submitBtn.onclick = function(){
		formSubmit();
	}

	Function.prototype.before = function( beforefn ){
		var __self = this;
		return function(){
			if ( beforefn.apply( this, arguments ) === false ){
	// beforefn 返回false 的情况直接return，不再执行后面的原函数
				return;
			}
			return __self.apply( this, arguments );
		}
	}


	var validata = function(){
		if ( username.value === '' ){
			alert ( '用户名不能为空' );
			return false;
		}
		if ( password.value === '' ){
			alert ( '密码不能为空' );
			return false;
		}
	}
	var formSubmit = function(){
		var param = {
			username: username.value,
			password: password.value
		}
		ajax( 'http:// xxx.com/login', param );
	}

	formSubmit = formSubmit.before( validata );

	submitBtn.onclick = function(){
		formSubmit();
	}
	
</script>
</html>