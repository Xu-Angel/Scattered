 // TODO: https://juejin.im/post/5c2e10a76fb9a049c0432697
 
 # 设计模式
 在这里设计模式大致分为三组:

 - `创建型模式`： 涉及对象的创建与初始化。

 - `结构型模式`： 描述了如何组合对象以提供新的功能。

 - `行为型模式`： 描述了对象间如何通信。


 `单件模式1（ 创建型）`

 此模式主要考虑的是创建对象的方式， 当需要创建一种类型或一个类的唯一对象。 在一般的语言中， 意味着这一个类只能被创建一个实例对象，
 如果之后再尝试创建该对象的话， 代码就只会返回原来的实例， 在JavaScript中本身没有类的概念， 所以单件成为了默认行为， 也是最自然的模式。
 每个对象都是一个单件。 最基本的单件模式实现是使用对象文本标识法：
 var single = {};

 `单件模式2（ 创建型）`

 构造函数形式的单件模式， 没有创建， 有的话则返回原本的那个。

 `工厂模式（ 创建型）`

 当有多个相似的对象而又不知道应该先使用哪种时， 考虑使用工厂模式， 此时， 代码会根据具体的输入或其他既定规则， 自行决定创建哪种类型的对象。
 例如用户点击按钮来决定创建一个Link || 图片 || 文本。 创建这三个东东的构造函数的方法都一样， 通过判断用户点击的类型写三个if语句。 用工厂模式，
 写一个方法， 根据类型传进一个参数再调用方法。

 `装饰器模式（ 结构型）`

 它与对象的创建无关， 主要考虑的是如何拓展对象的功能， 也就是除了使用线性式（ 父 - 子 - 孙） 继承方式外， 我们也可以为一个基础对象创建若干个装饰对象以拓展其功能。 然后， 由我们的程序自行选择不同的装饰器， 并按不同的顺序使用他们。
 eg: 装饰一个圣诞树

 `观察者模式（ 行为型）`

 有时候也称为发布 - 订阅模式， 主要用于处理不同对象之间的交互通信问题。 观察者模式通常包括两类对象：
 - 一个或多个发布者对象： 当有重要的事情发生时， 会通知订阅者。
 - 一个或多个订阅者对象： 它们追随一个或多个发布者， 监听他们的通知， 并做出相应的反映。

 eg: 浏览器事件就是一个典型应用， 浏览器作为发布者， 当一个事件发生的时候（ 例如onclick）， 他会发出通知。 事件坚挺着会监听这类事件， 并在事情
 发生时被通知

 本模式主要分为两大类： 推送和拉动
 - 推送： 发布者负责将消息通知给各个订阅者。
 - 拉动： 订阅者主动跟踪发布者的状态变化。
 编程模式， 行为隔离：
 内容， 外观， 行为 网页设计， 命名空间：

 尽量减少使用全局变量的机会， 更好的办法是将变量和方法定义在不同的命名空间中。 也就是定义一个全局变量， 然后将其他变量和方法定义
 为该变量的属性。
```javascript
 for (var i in properties) {
   if (properties.hasOwnProperty(i)) {
     tmp.setAttribute(i, properties[i])
   }
 }
 ```

`初始化分支`

 eg: 不同浏览器对于相同或相似的方法可能有不同的实现。

  此时， 根据当前的浏览器的支持方式来选择对应的执行分支。 例如在Listener方法上见兼容。当知道某个条件在整个程序生命周期都不会发生改变的时候， 我们仅仅只需要对该条件判断一次就可以了。
 每次在调用utils.addListener或utils.removeListener时， 都会重复的执行想同的检查， 效率是比较低下的。

 `初始延迟（ 惰性初始）`

 与上面的初始化分支很相似， 不同之处在于， 本模式下的分支只有在相关函数第一次被调用时才会发生—— 只有函数被调用时， 才会1️以最佳实现改写自己。
 这样使得初始化过程更为轻量， 因此不再需要做分支检测。 例如上面的Listener在本模式下用泛型的方式来实现

 `配置对象：`

 适用于有很多个参数的函数或方法， 此时可以用对象来代替多个参数。 也就是说， 让这些参数都成为某个对象的属性。 在面对一下配置型参数时会显得尤为合适。
 因为它们中往往存在多个缺省的参数。 有以下优势：
 - 可以不用考虑参数的顺序，
 - 可以跳过某些参数的设置，
 - 函数的扩展性更强， 可以适应将来的扩展需要，
 - 代码的可读性更好， 因为在代码中我们看到的是配置对象的属性名称。

 eg: 在写组件或者多参数的构造方法的时候:
 ```javascript
   b.type = type || 'submit'
 var config = {
   font: '',
   type: '',
   //....
 }
 ```

 作为一个经验法则， 这些参数都应该是独立而且可选的， 如果在函数中， 我们被徐为这些参数的组合检查各种可能性（‘ a参数被设置了， 但a参数只有在b参数被设置
 的时候才有效..’）

 `私有变量和方法`

 在JavaScript中， 没有可以用于设置对象属性访问权限的修饰符， 但是可以在构造器中通过使用局部变量和函数的方式来实现类似的权限控制。

 `特权函数` 

 也就是一些普通的公共函数， 但是他们却可以访问对象的私有方法或属性， 其作用类似一座桥梁， 将私有特性以一种可控的方式暴露给外部使用者

 `私有函数的公有化`

 在希望某些外部代码能访问一个私有函数， 则将这个私有函数赋值给一个公有属性， 但此时暴露私有方法与属性的时候， 要记住， 对象（ 函数以及数组也是对象）
 传递的方式为引用传递， 所以对象可以从外部被修改。
 ```javascript
   var MYAPP = {};
 MYAPP.dom = (function() {
     var _setStyle = function() {
       console.log('')
     }
     var _getStyle = function() {
       console.log('')
     }
     return {
       setStyle: _setStyle,
       getStyle: _getStyle,
       yetAnother: _setStyle
     }
   }())
  ```
  `即时函数`

这是一个保证全局命名空间不被污染的模式， 把代码封装在一个匿名函数中并且立即调用， 此时， 该函数中的所有变量都是局部的（ 此变量要使用var关键字）
并且在函数返回时被销毁（ 前提是他们不属于闭包）。

```javacript
   (function() {
     //立即调用的代码
   }())
```

 此模式特别合适某些脚本加载时执行的一次性初始化任务。

 `模块`
 模块模式下， 模块的概念帮助我们管理代码片段与库， 并在需要的时候引入他们。 通常模块模式包括以下几个部分：

 `命名空间` 用于减少模块间的命名冲突，

 `即时函数` 用于提供私有作用域以及初始化操作，

 `私有属性和方法`，
 作为返回值的对象： 该对象最为模块提供公共API。

`链式调用`
连续调用若干个彼此相关的方法时， 会带来很大的方便。 这里的前提就是通过一个方法的结果（ 即返回对象） 来调用下一个方法。 构造函数返回的是实例化对象`this`
不好的地方： 当出现错误的时候不知道是在哪一环出现错误的。