https://www.cnblogs.com/cuijl/p/8005741.html

https://mp.weixin.qq.com/s/39qlh4uFT2Gk-UkBKwSD6g  // 有一些错误的描述

# 高位字节、低位字节

一般一个16位（双字节）的数据，比如 FF1A  （16进制）
那么高位字节就是FF，低位是1A

如果是32位的数据，比如  3F68415B
高位字（不是字节）是3F68
低位字是415B

右边是低位位，左边是高位

# 16位和32位的数是怎么存储的？

一个16位的数占两个字节的存储空间，即高位字节和低位字节(见上图)。如果是在纸上书写一个16位的数，你总是会把高位字节写在前面，而把低位字节写在后面。然而，当这个数被存储到内存中时，并没有固定的存储顺序。

如果用M和L分别表示高位字节和低位字节，那么可以有两种方式把这两个字节存储到内存中，即M在前L在后或者L在前M在后。把M存储在前的顺序被称为“正向(forward)”或“高位优先顺序；把L存储在前的顺序被称为“逆向”或“低位优先”顺序。

>大多数计算机按正向顺序存储一个数，Intel CPU按逆向顺序存储一个数，因此，如果试图将基于Intel CPU的计算机连到其它类型的计算机上，就可能会引起混乱。

一个32位的数占4个字节的存储空间，如果我们按有效位从高到低的顺序，分别用Mm，Ml，Lm和Ll表示这4个字节，那么可以有4!(4的阶乘，即24)种方式来存储这些字节。在过去的这些年中，人们在设计计算机时，几乎用遍了这24种方式。然而，时至今天，只有两种方式是最流行的，一种是(Mm，MI，Lm，LD，也就是高位优先顺序，另一种是(Ll，Lm，Ml，Mm)，也就是低位优先顺序。和存储16位的数一样，大多数计算机按高位优先顺序存储32位的数，但基于Intel CPU的计算机按低位优先顺序存储32位的数。

# Socket相关知识点

网络字节序与主机字节序
主机字节序：就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：

　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。

# 为什么会有大小端模式之分呢？

这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。

# BOM

对于人类而言，字节序也许并不是问题。比如从右往左读"字节序"，聪明如你们，会发现“序节字”根本语义不通，可以轻松的找到解决之道。但对于计算机而言，它不明白什么是语义，也没法联系上下文。它只能按照给定的指令去读取字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。

所以对于计算机而言，我们需要一种方法去标识字节序，以防乱码的出现。BOM就是一种用于标识的unicode字符，它常被用来当做标示以UTF-8、UTF-16或UTF-32为编码的文件

对于UTF-16和UTF-32而言，因为他们分别使用2个字节和4个字节编码Unicode字符，对于多字节编码，BOM的存在显然很有必要。此时BOM被放置为文件或字符串流的第一个字符，如果标识符为 U+FFFE则表示大端字节序，如果标识符为 U+FEFF则表示小端字节序。

那既然BOM是用于标示字节序的，那为什么还要把它删除呢？这里就不得不提一下UTF-8了。

UTF-8是一种可变字节长度的编码方式（最小1字节，最大4字节），也就是说UTF-8可以根据数据大小来决定要存储的字节数。它的编码方式与其他两者不同，无需使用BOM。

UTF-8在首字节标识了字节的个数。如果首字节以0开头，则代表单字节编码，如果以110开头者表示该字节为两个字节中的第一个字节，以此类推。除了单字节外，多字节UTF-8码的后续字节均以10开头。

