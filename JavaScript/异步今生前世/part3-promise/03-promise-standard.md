# 对标一下 Promise/A+ 规范

Promise/A 是由 CommonJS 组织制定的异步模式编程规范，后来又经过一些升级，就是当前的 Promise/A+ 规范。上一节讲述的`Promise`的一些功能实现，就是根据这个规范来的。

## 本节内容概述

- 介绍规范的核心内容
- 状态变化
- `then`方法
- 接下来...

## 介绍规范的核心内容

网上有很多介绍 Promise/A+ 规范的文章，大家可以搜索来看，但是它的核心要点有以下几个，我也是从看了之后自己总结的

**关于状态**

- promise 可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）
- promise 的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换

**关于`then`方法**

- promise 必须实现`then`方法，而且`then`必须返回一个 promise ，同一个 promise 的`then`可以调用多次（链式），并且回调的执行顺序跟它们被定义时的顺序一致
- `then`方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用

下面挨个介绍这些规范在上一节代码中的实现，所谓理论与实践相结合。**在阅读以下内容时，你要时刻准备参考上一节的代码**。

## 状态变化

> promise 可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）

拿到上一节的`readFilePromise`函数，然后执行`const result = readFilePromise(someFileName)`会得到一个`Promise`对象。

- 刚刚创建时，就是 等待（pending）状态
- 如果读取文件成功了，`readFilePromise`函数内部的`callback`中会自定调用`resolve()`，这样就变为 已完成（fulfilled）状态
- 如果很不幸读取文件失败了（例如文件名写错了，找不到文件），`readFilePromise`函数内部的`callback`中会自定调用`reject()`，这样就变为 已拒绝（rejeced）状态

> promise 的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换

这个规则还是可以参考读取文件的这个例子。从一开始准备读取，到最后无论是读取成功或是读取失败，都是不可逆的。另外，读取成功和读取失败之间，也是不能互换的。这个逻辑没有任何问题，很好理解。

## `then`方法

> promise 必须实现`then`方法，而且`then`必须返回一个 promise ，同一个 promise 的`then`可以调用多次（链式），并且回调的执行顺序跟它们被定义时的顺序一致

- `promise`对象必须实现`then`方法这个无需解释，没有`then`那就不叫`promise`
- “而且`then`必须返回一个`promise`，同一个 promise 的`then`可以调用多次（链式）” ———— 这两句话说明了一个意思 ———— `then`肯定要再返回一个`promise`，要不然`then`后面怎么能再链式的跟一个`then`呢？

> `then`方法接受两个参数，第一个参数是成功时的回调，在 promise 由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在 promise 由“等待”态转换到“拒绝”态时调用

这句话比较好理解了，我们从一开始就在 demo 中演示。

## 接下来...

`Promise`的应用、规范都介绍完了，看起来挺牛的，也解决了异步操作中使用`callback`带来的很多问题。但是`Promise`本质上到底是一种什么样的存在，它是真的把`callback`弃而不用了吗，还是两者有什么合作关系？它到底是真的神通广大，还是使用了障眼法？

这些问题，大家学完`Promise`之后应该去思考，不能光学会怎么用就停止了。下一节我们一起来探讨~

## 求打赏

如果你看完了，感觉还不错，欢迎给我打赏 ———— 以激励我更多输出优质内容

![](http://images2015.cnblogs.com/blog/138012/201702/138012-20170228112237798-1507196643.png)